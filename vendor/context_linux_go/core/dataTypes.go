//
// INTEL CONFIDENTIAL
// Copyright 2017 Intel Corporation.
// 
// This software and the related documents are Intel copyrighted materials, and your use of them is governed
// by the express license under which they were provided to you (License). Unless the License provides otherwise,
// you may not use, modify, copy, publish, distribute, disclose or transmit this software or the related documents
// without Intel's prior written permission.
// 
// This software and the related documents are provided as is, with no express or implied warranties, other than
// those that are expressly stated in the License.
//

package core

import (
	"context_linux_go/logger"
	"crypto/x509"
	"fmt"
	"reflect"
)

// JSONSchema is a generic JSON schema representation.
// Values of the map can either be strings or nested instances of JSONSchema
type JSONSchema map[string]interface{}

// ProviderType represents an item type that a provider produces, including the URN and
// JSON schema
type ProviderType struct {
	URN    string
	Schema JSONSchema
}

// ProviderInterface represents the public API of a local provider.
//
// Some methods are exposed to be used internally within the Sensing core itself
type ProviderInterface interface {
	// Begin producing a stream of items on the onItem channel
	Start(onItem ProviderItemChannel, onErr ErrorChannel)
	// Stop the stream of items to the channel
	Stop()
	// Get the latest item directly without using the item channel.
	// This can either be the last value placed on the channel or a newly created
	// item
	GetItem(string) *ItemData
	// Return the types this Provider can emit. Each package should also expose
	// a Types() function that does not require a ProviderInterface instance to
	// work as well
	Types() []ProviderType
	// Return a pointer to the ProviderOptions struct for this provider.
	// This may be embedded within provider specific options, and is used internally
	// within the Sensing core.
	GetOptions() *ProviderOptions
}

// CommandFunc is a generic function pointer definition for all commands
// It accepts an arbitrary number of input arguments and returns an interface{} with the result
type CommandFunc func(...interface{}) interface{}

// CommandHandlerInterface is the generic interface that commands will implement
type CommandHandlerInterface interface {
	Start(map[string]interface{})
	Stop()
	Methods() map[string]CommandFunc //map of types to method calls
}

// CommandHandlerInfo is a struct containing the handler and map of types to method calls
type CommandHandlerInfo struct {
	Handler            CommandHandlerInterface
	Methods            map[string]CommandFunc
	MethodDoneChannels map[string]chan bool
	Publish            bool
}

// SensingOptions is the general options utilized by sensing
type SensingOptions struct { // nolint: aligncheck
	Application string
	Macaddress  string
	Server      string

	// Connect in secure mode using SSL or TLS
	Secure bool

	// A slice of trusted root certificates.  If this field is nil
	// then the default system roots will be used to verify the server
	// certificate. Only used if Secure == true
	// Example of loading a cerificate from a file in PEM format:
	// certBuf, err = ioutil.ReadFile("certificate_file.crt")
	// block, _ := pem.Decode(certBuf)
	// var cert *x509.Certificate
	// cert, err = x509.ParseCertificate(block.Bytes)
	RootCertificates []*x509.Certificate

	// Do not perform verification on the certificate passed by the server in secure mode.
	// Note this is suseptible to attacks and should only be used for debugging purposes.
	// Only used if Secure == true
	SkipCertificateVerification bool

	Retries       int
	RetryInterval int
	Publish       bool
	UseCache      bool
	LogFile       string
	LogLevel      logger.LogLevel
	NodeID        string
	Password      string

	OnStarted SensingStartedChannel
	OnError   ErrorChannel
}

// ProviderOptions is the list of common options for all providers. Only Publish should be filled in initially,
// the remaining options will be filled in by the Sensing core during EnableSensing
type ProviderOptions struct {
	// True if the events from this provider should be published to the bus
	Publish bool

	// Identifier of this provider instance, updated during EnableSensing call
	ProviderID int

	// Pointer to the Sensing object to which this provider is attached
	// Must do a type assertion 'Sensing.(sensing.Sensing)' to avoid import cycles
	// Filled in during EnableSensing call
	Sensing interface{}
}

// ItemData is a generic representation of all objects generated by providers in the
// Context Sensing Go SDK
type ItemData struct {
	MacAddress  string      `json:"macaddress"`
	Application string      `json:"application"`
	ProviderID  int         `json:"providerId"`
	DateTime    string      `json:"dateTime"`
	Type        string      `json:"type"`
	Value       interface{} `json:"value"`
}

// ErrorData is a type definition of objects of type error
type ErrorData struct {
	Error error
}

// SensingStarted is a type definition of a bool value, to indicate if sensing has started or not
type SensingStarted struct {
	Started bool
}

// ErrorChannel is a type definition for a channel to report errors that occur in core
type ErrorChannel chan ErrorData

// ProviderItemChannel is a type definition for a channel to return ItemData pointers
type ProviderItemChannel chan *ItemData

// SensingStartedChannel is a type definition for a channel to return that sensing has started or not
type SensingStartedChannel chan *SensingStarted

// ToString creates a JSON formatted string of ItemData
func (item *ItemData) ToString() string {
	var output = "{ "
	output += fmt.Sprintf("type: '%s',\n", item.Type)
	output += fmt.Sprintf("value: {")
	val := reflect.ValueOf(item.Value)
	switch val.Kind() {
	case reflect.Map:
		for _, key := range val.MapKeys() {
			output += fmt.Sprintf("%s: %v\n", key, val.MapIndex(key))
		}
	default:
		output += fmt.Sprintf("%v", val)
	}
	output += fmt.Sprintf("},\n")
	output += fmt.Sprintf("macaddress: '%s',\n", item.MacAddress)
	output += fmt.Sprintf("application: '%s',\n", item.Application)
	output += fmt.Sprintf("providerId: '%d',\n", item.ProviderID)
	output += fmt.Sprintf("dateTime: '%s',\n", item.DateTime)
	output += "}"

	return output
}